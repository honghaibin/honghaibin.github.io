{"meta":{"title":"随便起居","subtitle":"honghaibin's personal blog.","description":"随便起居，从零开始，记录前端漫漫路。","author":"洪海斌，Haibin Hong","url":"http://blog.honghaibin.com"},"pages":[{"title":"","date":"2017-05-21T02:15:31.068Z","updated":"2017-04-20T16:49:52.989Z","comments":true,"path":"sw.js","permalink":"http://blog.honghaibin.com/sw.js","excerpt":"","text":"'use strict'; const version = 'v20170408'; const __DEVELOPMENT__ = false; const __DEBUG__ = false; const offlineResources = [ '/', '/offline.html', '/offline.svg' ]; const matchFetch = [ /https?:\\/\\/huaji8.top\\// ]; ////////// // Install ////////// function onInstall(event) { log('install event in progress.'); event.waitUntil(updateStaticCache()); } function updateStaticCache() { return caches .open(cacheKey('offline')) .then((cache) => { return cache.addAll(offlineResources); }) .then(() => { log('installation complete!'); }); } //////// // Fetch //////// function onFetch(event) { const request = event.request; if (shouldAlwaysFetch(request)) { event.respondWith(networkedOrOffline(request)); return; } if (shouldFetchAndCache(request)) { event.respondWith(networkedOrCached(request)); return; } event.respondWith(cachedOrNetworked(request)); } function networkedOrCached(request) { return networkedAndCache(request) .catch(() => { return cachedOrOffline(request) }); } // Stash response in cache as side-effect of network request function networkedAndCache(request) { return fetch(request) .then((response) => { var copy = response.clone(); caches.open(cacheKey('resources')) .then((cache) => { cache.put(request, copy); }); log(\"(network: cache write)\", request.method, request.url); return response; }); } function cachedOrNetworked(request) { return caches.match(request) .then((response) => { log(response ? '(cached)' : '(network: cache miss)', request.method, request.url); return response || networkedAndCache(request) .catch(() => { return offlineResponse(request) }); }); } function networkedOrOffline(request) { return fetch(request) .then((response) => { log('(network)', request.method, request.url); return response; }) .catch(() => { return offlineResponse(request); }); } function cachedOrOffline(request) { return caches .match(request) .then((response) => { return response || offlineResponse(request); }); } function offlineResponse(request) { log('(offline)', request.method, request.url); if (request.url.match(/\\.(jpg|png|gif|svg|jpeg)(\\?.*)?$/)) { return caches.match('/offline.svg'); } else { return caches.match('/offline.html'); } } /////////// // Activate /////////// function onActivate(event) { log('activate event in progress.'); event.waitUntil(removeOldCache()); } function removeOldCache() { return caches .keys() .then((keys) => { return Promise.all( // We return a promise that settles when all outdated caches are deleted. keys .filter((key) => { return !key.startsWith(version); // Filter by keys that don't start with the latest version prefix. }) .map((key) => { return caches.delete(key); // Return a promise that's fulfilled when each outdated cache is deleted. }) ); }) .then(() => { log('removeOldCache completed.'); }); } function cacheKey() { return [version, ...arguments].join(':'); } function log() { if (developmentMode()) { console.log(\"SW:\", ...arguments); } } function shouldAlwaysFetch(request) { return __DEVELOPMENT__ || request.method !== 'GET' || !matchFetch.some(regex => request.url.match(regex)); } function shouldFetchAndCache(request) { return ~request.headers.get('Accept').indexOf('text/html'); } function developmentMode() { return __DEVELOPMENT__ || __DEBUG__; } log(\"Hello from ServiceWorker land!\", version); self.addEventListener('install', onInstall); self.addEventListener('fetch', onFetch); self.addEventListener(\"activate\", onActivate);"},{"title":"关于本站","date":"2017-04-04T11:05:00.000Z","updated":"2017-05-21T05:54:54.100Z","comments":true,"path":"关于本站.html","permalink":"http://blog.honghaibin.com/关于本站.html","excerpt":"","text":"我希望这个博客能伴我一生。 友情链接: 本站主题：one 我喜欢的 blog : 阮一峰的网络日志嗯~ 我在这里学会了很多。"},{"title":"关于我","date":"2017-01-14T08:58:59.000Z","updated":"2017-05-21T05:55:31.575Z","comments":true,"path":"关于我.html","permalink":"http://blog.honghaibin.com/关于我.html","excerpt":"","text":"拼命想抓住一些东西！前端 程序员 主攻web node全栈 喜欢 编程，游戏，音乐，动漫 QQ：1261998551 邮箱：15867179361@163.com 网易云音乐: 帅到不可以 github: honghaibin 网易云: 帅到不可以 喜欢歌手: 双笙子、JJ、许嵩"},{"title":"","date":"2017-04-23T02:18:10.489Z","updated":"2017-04-23T02:18:10.489Z","comments":true,"path":"head/piwik.html","permalink":"http://blog.honghaibin.com/head/piwik.html","excerpt":"","text":""},{"title":"","date":"2017-04-23T02:18:19.024Z","updated":"2017-04-23T02:18:19.024Z","comments":true,"path":"head/serviceWorker.html","permalink":"http://blog.honghaibin.com/head/serviceWorker.html","excerpt":"","text":""}],"posts":[{"title":"lambda-view--一个优秀的javascript阅读器","slug":"lambda-view","date":"2017-05-24T05:40:00.000Z","updated":"2017-05-24T05:41:49.020Z","comments":true,"path":"2017/05/24/lambda-view/","link":"","permalink":"http://blog.honghaibin.com/2017/05/24/lambda-view/","excerpt":"","text":"介绍 lambda-view provides you a better way to READ JavaScript source code. 不是一个文本编辑器，而是一个针对于javascript的阅读器。 它了解javascript的语法，在AST级别运行，而不是简单的象征性的高亮显示。 它能根据需要转换和再现源代码。 它拥有高度优化的阅读界面的设计与布局。 建立在一个小型web服务器智商，你可以用别的设备通过在同一个wifi环境下访问阅读界面。 安装1npm install -g lambda-view 使用1lv target.js 如果一切正常就会在web浏览器中自动打开并显示结果 一些有用的提示 lv命令接受URL： 1lv https://code.jquery.com/jquery-3.1.1.js 可以一个命令打开多个文件 1lv file1.js file2.js file3.js lambda视图嵌入了一个仅在默认情况下接受本地访问的小型Web服务器。但是您可以重新配置以接受公共访问。这使您的计算机成为可以由您的iphone / ipad访问的Web服务器。 你可以通过下面三个步骤完成： step-1 停止当前的lambda视图web服务器 1lv-svr stop step-2 启动具有公共模式的lambda视图Web服务器 1lv-svr start --public --background step-3 打开您要在iphone / ipad上阅读的任何JavaScript文件 1lv some-file.js 参考链接 lambda-view in github","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.honghaibin.com/categories/工具/"}],"tags":[{"name":"node","slug":"node","permalink":"http://blog.honghaibin.com/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://blog.honghaibin.com/tags/npm/"}]},{"title":"Localtunnel--内网穿透工具的安装和使用","slug":"localtunnel","date":"2017-05-24T04:10:00.000Z","updated":"2017-05-24T03:44:27.182Z","comments":true,"path":"2017/05/24/localtunnel/","link":"","permalink":"http://blog.honghaibin.com/2017/05/24/localtunnel/","excerpt":"","text":"简介 Localtunnel将你的localhost服务暴露向外网，方便测试和分享！不需要DNS解析和部署就可以让别人轻易看到你所做的更改。 安装1npm install -g localtunnel 使用Localtunnel 首先，开启你的本地服务后（可以通过http://localhost:3000访问），在命令行中输入： 1lt --port 3000 或 lt -p 3000 在命令行中会返回给你一个url：your url is:https://kasdad.localtunnel.me 这个时候你就可以在外网访问这个url访问你的本地服务了。 使用自定义域名 上面的url中”kasdad”是随机生成的域名，如果你需要自定义自己的域名，以“wahaha”为例，可以使用命令： 1234lt --subdomain wahaha --port 3000 或 lt -s wahaha -p 3000 //subdomain的字符数限制在4到63个字符之间。 参考网站 localtunnel的github地址","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.honghaibin.com/categories/工具/"}],"tags":[{"name":"node","slug":"node","permalink":"http://blog.honghaibin.com/tags/node/"}]},{"title":"论一名前端工程师の自我修养","slug":"前端规范","date":"2017-05-22T13:42:00.000Z","updated":"2017-05-24T03:19:35.876Z","comments":true,"path":"2017/05/22/前端规范/","link":"","permalink":"http://blog.honghaibin.com/2017/05/22/前端规范/","excerpt":"","text":"1. 可维护性 很多时候，我们不是从零开始，开发新代码。而是去维护别人的代码，以他人的工作成果为基础。确保自己的代码可维护，是赠人玫瑰， 手留余香的好事。一方面让别人看的舒服，另一方面也防止自己长时间没看过自己的代码，自己都难以理解。 1.1 什么是可维护性代码 可维护性代码的一些特征： 可理解 ：易于理解代码的用途 可适应 ：数据的变化，不需要完全重写代码 可扩展 ：要考虑未来对核心功能的扩展 可调试 ：给出足够的信息，让调试的时候，确定问题所在 不可分割 ：函数的功能要单一，功能粒度不可分割，可复用性增强 1.2 代码约定1.2.1 可读性 统一的缩进方式 ： 一般使用4个空格，不用制表符是因为制表符在不同的编辑器里的效果不同。 注释 ： 函数和方法、大段代码、复杂的算法、hack 空白行 ： 方法之间、方法里的局部变量和第一个语句之间、单行或者多行注释之间、方法内依个逻辑单元之间 1234567891011121314151617// Goodif (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == &apos;object&apos;) &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 1.2.2 变量名和函数名 驼峰命名法 变量名以名词开头 方法名以动词开头 常量全部大写 构造函数以大写字母开头 jquery对象以“$”符号开头 变量命名不仅仅是一种科学，更是一种艺术。总之，要短小精悍，见名知意。有些名词可以反应出变量的类型。 变量名： 名词 数据类型含义 count,length,size 数值 name,title,message 字符串 i,j,k 用来循环 car,person,student,user 对象 success,fail 布尔值 payload post数据的请求体 method 请求方式 函数名： 动词 用法 resend 重发 validate 验证 query 查询 create 创建 add 添加 delete 删除 remove 移除 insert 插入 update 更新 copy 复制 render 渲染 close 关闭 open 开启 clear 清除 edit 编辑 on 当事件发生 list 渲染一个列表，例如 listUsersList() 或 listUsers() 接口常用的动词： 含义 请求方法 词语 例子 增加 post create createUser 删除 delete delete deleteUser 修改 update update updateUser 查询 get get,query getUser,queryUser(无条件查询用get，有条件的查询用query) 学会使用单复数命名函数： 函数名 含义 getUser() 获取一个用户，一般是通过唯一的id来获取 getUsers() 获取一类用户，一般是通过一些条件来获取 createUser() 创建一个用户 createUsers() 批量创建用户 常量： 12var MAX_COUNT= 10;var URL= &quot;http://material.io&quot;; 构造函数： 12345678// Goodfunction Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var me = new Person(&quot;wdd&quot;); 底层http请求接口函数： 建议使用“_”开头，例如App._getUsers();而对于接口函数的封装，例如App.getUsers()，内部逻辑调用App._getUsers(); 1.2.3 文件名 * 全部使用小写字母 * 单词之间用“_”间隔 eg: 12app-main.jsapp-event.js 1.2.4 文件归类 自己写的js最好和第三方插件放置在不同的文件夹下。 1.2.5 alert只用于调试 如果你用alert来显示提醒消息，那么用户除了点击alert上的的确定按钮外，就只能点击上面的关闭，或者选择禁止再选择对话框，除此以外什么都不能操作。 有些浏览器如果禁止了alert的选项，那么你的alert是不会显示的 如果你在try catch语句里使用alert，那么console里将不会输出错误信息，你都没办法查看错误的详细原因，以及储出错的位置。 优雅的方式： console.log() 普通提示消息 console.error() 错误提示消息 console.info() 信息提示消息 console.warn() 警告提示消息 1.3 松散耦合 html文件最好避免写js语句 尽量避免在js更改某个css类的属性，而使用更改类的方法 解耦应用逻辑和事件处理程序 1.3.1 将应用逻辑和事件处理程序解耦 错误的做法：1234567891011//一般事件订阅的写法，以jQuery的写法为栗子$(document).on(&apos;click&apos;,&apos;#btn-get-users&apos;,function(event)&#123; event.stopPropagation(); //下面的省略号表示执行获取所有用于并显示在页面上的逻辑 // Bad ... ... ... //&#125;); 如果增加了需求，当点击另外一个按钮的时候，也要执行获取所有用户并显示在页面上，那么上面省略的代码又要复制一份。如果接口有改动，那么需要在两个不同的地方都要修改。所以，应该这样。 12345678$(document).on(&apos;click&apos;,&apos;#btn-get-users&apos;,function(event)&#123; event.stopPropagation(); //将应用逻辑分离在其他个函数中 // Good App.getUsers(); App.renderUsers();&#125;); 1.3.2 松散解耦原则 不要将event对象传给其他方法，只传递来自event对象中的某些数据。 任何事件处理程序都应该只处理事件，然后将处理转交给应用逻辑。 1.3.3 将异步请求和数据处理解耦 错误做法：123456789101112// BadReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123; if(!res.success)&#123; console.error(res); return; &#125; //对数据的处理 ... ... ...&#125;); 上面代码对数据的处理直接写死在异步请求里面，如果换了一个请求，但是数据处理方式是一样的，那么又要复制一遍数据处理的代码。最好的方式是将数据处理模块化成为一个函数。 12345678910// GoodReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123; if(!res.success)&#123; console.error(res); return; &#125; //对数据的处理 App.renderUsers(res.data);&#125;); ps:异步请求只处理请求，不处理数据。函数的功能要专一，功能粒度不可分割。 1.3.4 不要将某个变量写死在函数中，尽量使用参数传递进去 如果你需要一个函数去验证输入框是否是空，如下。这种方式就会绑定死了这个只能验证id为test的输入框，换成其他的就不行。 123456789101112131415161718192021// badfunction checkInputIsEmpty()&#123; var value = $(&apos;#test&apos;).val(); if(value)&#123; return true; &#125; else&#123; return false; &#125;&#125;// goodfunction isEmptyInput(id)&#123; var value = $(&apos;#&apos;+id).val(); if(value)&#123; return true; &#125; else&#123; return false; &#125;&#125; 1.4 编程实践1.4.1 尊重对象所有权 javascript的动态性质决定了几乎属于它的任何东西在任何时间都能发生更改，这样就很可能会篡改一些默认的方法，从而导致一些灾难性的后果。如果你不负责或者维护某一个对象，那么你就不能对它进行更改。 * 不要为实例或原型添加属性和方法 * 不要重定义已存在的方法 1.4.2 避免全局变量 避免全局变量的深层原因在于避免作用域污染 作用域就像空气，你时时刻刻不在呼吸，但你往往感觉不到它的存在。一旦它本污染。你就会感到窒息 12345678910111213// Bad 两个全局变量var name = &quot;wdd&quot;;funtion getName()&#123; console.log(name);&#125;// Good 一个全局变量var App = &#123; name:&quot;wdd&quot;, sayName:funtion()&#123; console.log(this.name);//如果这个函数当做回调数使用，这个this可能指向window, &#125;&#125;; 1.4.3 避免与null进行比较 1234567891011121314//Badfuntion sortArray(values)&#123; // 避免 if(values != null)&#123; values.sort(comparator); &#125;&#125;//Goodfunction sortArray(values)&#123; // 推荐 if(values instanceof Array)&#123; values.sort(compartor); &#125;&#125; 与null进行比较的代码，可以用以下技术进行替换 &gt; 如果值是一个应用类型，使用instanceof操作符，检查其构造函数 如果值是基本类型，使用typeof检查其类型 如果是希望对象包含某个特定的方法名，则只用typeof操作符确保指定名字的方法存在于对象上。 代码中与null比较越少，就越容易确定代码的目的，消除不必要的错误。 1.4.4 从代码中分离配置文件 配置数据是一些硬代码(hardcoded),看下面的例子： 123456function validate(value)&#123; if(!value)&#123; alert(&apos;Invalid value&apos;); location.href = &apos;/errors/invalid.php&apos;; &#125;&#125; 上面代码里有两个配置数据，一个是UI字符串(‘Invalid value’),另一个是一个Url(‘/error/invalid.php’)。如果你把他们写死在代码里，那么如果当你需要修改这些地方的时候，那么你必须一处一处的检查并修改，而且还可能会遗漏。 所以第一步是要区分，哪些代码应该写成配置文件的形式？ * 显示在UI元素中的字符串 * URL * 一些重复的唯一值（例如URL） * 一些设置变量 * 任何可能改变的值 1234var Config = &#123; &quot;MSG_INVALID_VALUE&quot;:&quot;Invalid value&quot;, &quot;URL_INVALID&quot;:&quot;/errors/invalid.php&quot;&#125; 1.4.5 调试信息开关 在开发过程中，可能随处留下几个console.log,或者alert语句，这些语句在开发过程中是很有价值的。但是项目一旦进入生产环境，过多的console.log可能影响到浏览器的运行效率，过多的alert会降低程序的用户体验。而我们最好不要在进入生产环境前，一处一处像扫雷一样删除或者注释掉这些调试语句。 最好的方法就是设置一个开关 123456789101112131415161718192021//全局命令空间var App = &#123; debug:true, log:function(msg)&#123; if(debug)&#123; console.log(msg); &#125; &#125;, alert:function(msg)&#123; if(debug)&#123; alert(msg); &#125; &#125;&#125;;//使用App.log(&apos;获取用户信息成功&apos;);App.alert(&apos;密码不匹配&apos;);//关闭日志输出与alertApp.debug = false; 1.4.6 使用jQuery Promise 没有使用promise之前的回调函数写法： 1234567891011121314151617181920212223242526272829// bad：没使用promise之前的回调函数写法function sendRequest(req,successCallback,errorCallback)&#123; var inputData = req.data || &#123;&#125;; inputData = JSON.stringify(inputData); $.ajax(&#123; url:req.base+req.destination, type:req.type || &quot;get&quot;, headers:&#123; sessionId:session.id &#125;, data:inputData, dataType:&quot;json&quot;, contentType : &apos;application/json; charset=UTF-8&apos;, success:function(data)&#123; successCallback(data); &#125;, error:function(data)&#123; console.error(data); errorCallback(data); &#125; &#125;);&#125;//调用sendRequest(req,function(res)&#123; ...&#125;,function(res)&#123; ...&#125;); 使用promise之后 12345678910111213141516171819202122232425262728293031323334function sendRequest(req)&#123; var $dfd = $.Deferred(); var inputData = req.data || &#123;&#125;; inputData = JSON.stringify(inputData); $.ajax(&#123; url:req.base+req.destination, type:req.type || &quot;get&quot;, headers:&#123; sessionId:session.id &#125;, data:inputData, dataType:&quot;json&quot;, contentType : &apos;application/json; charset=UTF-8&apos;, success:function(data)&#123; $dfd.resolve(data); &#125;, error:function(data)&#123; $dfd.reject(data); &#125; &#125;); return $dfd.promise();&#125;//调用sendRequest(req).done(function()&#123; //请求成功 ...&#125;).fail(function()&#123; //请求失败 ...&#125;); 1.4.7 显示错误提醒，不要给后端接口背锅 假如前端要去接口获取用户信息并显示出来，如果你的请求格式是正确的，但是接口返回400以上的错误，你必须通过提醒来告知测试，这个错误是接口的返回错误，而不是前端的逻辑错误。 1.4.8 Restful接口请求 对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。 请求类型 接口前缀 GET .get POST .create PUT .update DELETE .delete 有些接口获取某一些资源虽然是post请求，但是它的行为是get，所以建议使用.get 示例： // 与用户相关的接口 App.api.user = {}; // 获取一个用户: 一般来说是一个指定的Id，例如userId App.api.user.getUser = function(){ ... }; // 获取一组用户: 一般来说是一些条件，获取条件下的用户，筛选符合条件的用户 App.api.user.getUsers = function(){ ... }; // 创建一个用户 App.api.user.createUser = function(){ }; // 创建一组用户 App.api.user.createUsers = function(){ }; // 更新一个用户 App.api.user.updateUser = function(){ }; // 更新一组用户 App.api.user.updateUsers = function(){ }; // 更新一个用户 App.api.user.updateUser = function(){ }; // 更新一组用户 App.api.user.updateUsers = function(){ }; // 删除一个用户 App.api.user.deleteUser = function(){ }; // 删除一组用户 App.api.user.deleteUsers = function(){ }; 2 性能2.1 注意作用域 避免全局查找 避免with语句,虽然方便，但是这个会进行全局搜索。 提示：with语句的用法12345678910111213function Lakers() &#123; this.name = &quot;kobe bryant&quot;; this.age = &quot;28&quot;; this.gender = &quot;boy&quot;; &#125; var people=new Lakers(); with(people) &#123; var str = &quot;姓名: &quot; + name + &quot;&lt;br&gt;&quot;; str += &quot;年龄：&quot; + age + &quot;&lt;br&gt;&quot;; str += &quot;性别：&quot; + gender; document.write(str); &#125; 2.2 选择正确的方法 优化循环 减值迭代：从最大值开始，在循环中不断减值的迭代器更加高效。 简化终止条件：由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是避免其他属性查找。 简化循环体：由于循环体是执行最多的，所以要确保其最大限度地优化。 展开循环 避免双重解释 12345678// **Bad** 某些代码求值eval(&quot;alert(&apos;hello&apos;)&quot;);// **Bad** 创建新函数var sayHi = new Function(&quot;alert(&apos;hello&apos;)&quot;);// **Bad** 设置超时setTimeout(&quot;alert(&apos;hello&apos;)&quot;); 性能的其他注意事项 原生方法较快 switch语句较快：可以适当的替换ifelse语句case 的分支不要超过128条 位运算符较快 2.3 最小化语句数多个变量声明： 123456789101112// 方式1：Badvar count = 5;var name = &apos;wdd&apos;;var sex = &apos;male&apos;;var age = 10;// 方式2：Goodvar count = 5, name = &apos;wdd&apos;, sex = &apos;male&apos;, age = 10;_如果你觉得可读性变差了，可以不使用，个人很是喜欢这么写_ 插入迭代值 12// Goodvar name = values[i++]; 使用数组和对象字面量 123456789// Goodvar values = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var person = &#123; name:&apos;wdd&apos;, age:10&#125;;提示：只要有可能，尽量使用数组和对象字面量的表达式来消除不必要的语句 2.4 优化DOM交互 在JavaScript各个方面中，DOM无疑是最慢的一部分。DOM操作与交互要消耗大量的时间。因为他们往往需要重新渲染整个页面或者某一部分。进一步说，看似细微的操作也可能花很久来执行。因为DOM要处理非常多的信息。理解如何优化与DOM的交互可以极大的提高脚本完成的速度。 使用dom缓存技术 最小化现场更新 使用innerHTML插入大段的html 使用事件代理 2.4.1 Dom缓存技术 调用频率非常高的dom查找，可以将Dom缓存于一个变量中 1234567// 最简单的dom缓存var domCache = &#123;&#125;;//如果之前查过一次，就用缓存中的function myGetElement(tag)&#123; return domCache[tag] = domCache[tag] || $(tag);&#125; 2.5 避免过长的属性查找，设置一个快捷方式12345678910// 先看下面的极端情况app.user.mother.parent.home.name = &apos;haha&apos;app.user.mother.parent.home.adderess = &apos;上海&apos;app.user.mother.parent.home.weather = &apos;晴天&apos;// 更优雅的方式var home = app.user.mother.parent.home;home.name = &apos;haha&apos;;home.address = &apos;上海&apos;,home.weather = &apos;晴天&apos; 注意： 使用上面的方式是有前提的，必须保证app.user.mather.parent.home是一个对象，因为对象是传递的引用。如果他的类型是一个基本类型，例如：number,string,boolean，那么复制操作仅仅是值传递，新定义的home的改变，并不会影响到app.user.mather.parent.home的改变。 3 快捷方式3.1 字符串转数字1+&apos;4.1&apos; === 4.1 //true 3.2 数字转字符14.1+&quot;&quot;===&quot;4.1&quot; //true 3.3 字符串取整1&apos;4.99&apos; | 0===4 //true 4 推荐阅读 《编写可读代码的艺术》 《编写可维护的javascript》 《JavaScript忍者秘籍》 写在最后的话： 这篇文章原文出自我同事： 前端干货之JS最佳实践 我们毕业于一所大学，一起进公司实习，通过试用，最后转正。转眼间已经一年半了。 刚到公司那会儿，在没有前端前辈带我们的情况下，我们走了很多弯路，如今再看看我们以前敲的那些代码简直是不忍回去再看。也多亏了我这位同事善于钻研，带着我学习了很多新东西。他以后肯定会成为一个前端大牛的，恩~我也会努力成为一名前端大牛的。","categories":[{"name":"规范","slug":"规范","permalink":"http://blog.honghaibin.com/categories/规范/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.honghaibin.com/tags/前端/"}]},{"title":"从零开始--基于hexo搭建个人博客","slug":"hexo+github","date":"2017-04-19T06:14:43.000Z","updated":"2017-05-24T01:21:00.777Z","comments":true,"path":"2017/04/19/hexo+github/","link":"","permalink":"http://blog.honghaibin.com/2017/04/19/hexo+github/","excerpt":"","text":"前言很早以前就想搭建一个个人技术博客了！我想用Hexo搭建博客原因有三：第一，它是纯一个静态博客，很适合前端用来搭建；第二，它基于node（你们都懂，前端和node不分家）；第三，好看，相对于csdn那些博客，hexo搭建的博客简单朴实很多。 hexo的开发者是一个大学生啊（笑哭~~），我觉得我可能读了个假大学！ 好了，感慨的话就不多说了，第一篇文章就献给hexo，感谢hexo！ 准备工作拥有Github账号这个就不多说了！（前端程序猿的基本素养） 创建一个仓库(repository)在github上创建一个仓库名称为 [yourname].github.io ([yourname]是你的github昵称！) 添加秘钥打开git bash命令行生成秘钥，命令如下：（友情提示:git官网下载很慢，记得先翻墙.） 1ssh-keygen -t rsa -C \"Github的注册邮箱地址\" 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh 验证ssh在github上添加完ssh之后并不会立刻生效，你需要在git bash命令行中输入： 1ssh -T git@github.com tip：如果你提交github不上的时候就要想到去验证一下ssh是否失效了。 在coding上添加完ssh之后也并不会立刻生效，你需要在git bash命令行中输入： 1ssh -T git@git.coding.net 成功提示： Hi xxxxxx! You’ve successfully authenticated, but GitCafe does not provide shell access. 然后刷新github的ssh设置页面，看到那一把钥匙变成绿色之后就说明你的环境已经部署好了。 配置git配置git：昵称和邮箱（我用的是github和hexo来搭建的，那就是我的github昵称和邮箱） 12git config --global user.name \"yourname\"git config --global user.email \"youremail\" hexo安装配置：下载安装、初始化1cnpm install -g hexo-cli 安装好之后输入 hexo 可以查看hexo各项命令。 123456// 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字 hexo init &lt;folder&gt;// 进入博客文件夹，&lt;folder&gt;为文件夹的名称 cd &lt;folder&gt;// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包 cnpm install 配置打开_config.yml文件，这里进行简单的配置(详情可以查看官方文档): 1.修改网站相关信息： title: inerdstack subtitle: the stack of it nerds description: start from zero author: inerdstack language: zh-CN timezone: Asia/Shanghai language和timezone都是有输入规范的，详细可参考语言规范和时区规范。 2.配置统一资源定位符（个人域名） url: http://balabala.com (这个url不能不写，不写会报错) 3.配置部署(repo是你创建的github仓库的pull地址，默认分支master) deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 2017/05/20更新：由于在国内访问github加载速度不尽人意，所以我把项目同时部署到了github上和coding上，配置部署变化如下： deploy: type: git repo: github: ssh://git@github.com/yourname/yourname.github.io.git,master coding: ssh://git@git.coding.net/yourname/yourname.git,master tip:详细配置操作可以查看参考资料 开始写文章创建一个文章1hexo new \"My New Post\" 更多详情:：writing 开启本地服务1hexo server 更多详情：Server 生成静态文件1hexo generate 更多详情: Generating 上传github1hexo deploy 更多详情：Deployment 写在最后的话： 创建好博客之后你就可以通过地址 https://honghaibin.github.io/ 进行访问你的博客了，如果不想在地址中显示“github”的字样，你可以去 万网 租一个域名,然后将你申请的这个域名通过dns解析指向github这个服务就ok了，是不是很酷炫。 参考资料域名+解析+Github关联参考链接 关于同时配置coding和github的参考链接","categories":[{"name":"教程","slug":"教程","permalink":"http://blog.honghaibin.com/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.honghaibin.com/tags/Hexo/"},{"name":"git","slug":"git","permalink":"http://blog.honghaibin.com/tags/git/"},{"name":"博客","slug":"博客","permalink":"http://blog.honghaibin.com/tags/博客/"}]}]}