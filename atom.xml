<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起居</title>
  <subtitle>honghaibin&#39;s personal blog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.honghaibin.com/"/>
  <updated>2017-05-24T05:41:49.020Z</updated>
  <id>http://blog.honghaibin.com/</id>
  
  <author>
    <name>洪海斌，Haibin Hong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lambda-view--一个优秀的javascript阅读器</title>
    <link href="http://blog.honghaibin.com/2017/05/24/lambda-view/"/>
    <id>http://blog.honghaibin.com/2017/05/24/lambda-view/</id>
    <published>2017-05-24T05:40:00.000Z</published>
    <updated>2017-05-24T05:41:49.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>lambda-view provides you a better way to READ JavaScript source code.</p>
</blockquote>
<ul>
<li>不是一个文本编辑器，而是一个针对于javascript的阅读器。</li>
<li>它了解javascript的语法，在AST级别运行，而不是简单的象征性的高亮显示。</li>
<li>它能根据需要转换和再现源代码。</li>
<li>它拥有高度优化的阅读界面的设计与布局。</li>
<li>建立在一个小型web服务器智商，你可以用别的设备通过在同一个wifi环境下访问阅读界面。</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g lambda-view</div></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lv target.js</div></pre></td></tr></table></figure>
<p>如果一切正常就会在web浏览器中自动打开并显示结果</p>
<h1 id="一些有用的提示"><a href="#一些有用的提示" class="headerlink" title="一些有用的提示"></a>一些有用的提示</h1><ul>
<li><p>lv命令接受URL：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lv https://code.jquery.com/jquery-3.1.1.js</div></pre></td></tr></table></figure>
</li>
<li><p>可以一个命令打开多个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lv file1.js file2.js file3.js</div></pre></td></tr></table></figure>
</li>
<li><p>lambda视图嵌入了一个仅在默认情况下接受本地访问的小型Web服务器。但是您可以重新配置以接受公共访问。这使您的计算机成为可以由您的iphone / ipad访问的Web服务器。
你可以通过下面三个步骤完成：</p>
</li>
</ul>
<p>step-1 停止当前的lambda视图web服务器
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lv-svr stop</div></pre></td></tr></table></figure></p>
<p>step-2 启动具有公共模式的lambda视图Web服务器
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lv-svr start --public --background</div></pre></td></tr></table></figure></p>
<p>step-3 打开您要在iphone / ipad上阅读的任何JavaScript文件
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lv some-file.js</div></pre></td></tr></table></figure></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/Jianru-Lin/lambda-view" target="_blank" rel="external">lambda-view in github</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;lambda-view provides you a better way to READ JavaScript 
    
    </summary>
    
      <category term="工具" scheme="http://blog.honghaibin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="node" scheme="http://blog.honghaibin.com/tags/node/"/>
    
      <category term="npm" scheme="http://blog.honghaibin.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Localtunnel--内网穿透工具的安装和使用</title>
    <link href="http://blog.honghaibin.com/2017/05/24/localtunnel/"/>
    <id>http://blog.honghaibin.com/2017/05/24/localtunnel/</id>
    <published>2017-05-24T04:10:00.000Z</published>
    <updated>2017-05-24T03:44:27.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>Localtunnel将你的localhost服务暴露向外网，方便测试和分享！不需要DNS解析和部署就可以让别人轻易看到你所做的更改。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g localtunnel</div></pre></td></tr></table></figure>
<h1 id="使用Localtunnel"><a href="#使用Localtunnel" class="headerlink" title="使用Localtunnel"></a>使用Localtunnel</h1><blockquote>
<p>首先，开启你的本地服务后（可以通过<a href="http://localhost:3000访问），在命令行中输入：" target="_blank" rel="external">http://localhost:3000访问），在命令行中输入：</a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lt --port 3000 或 lt -p 3000</div></pre></td></tr></table></figure></p>
<p>在命令行中会返回给你一个url：your url is:<a href="https://kasdad.localtunnel.me" target="_blank" rel="external">https://kasdad.localtunnel.me</a> 
这个时候你就可以在外网访问这个url访问你的本地服务了。  </p>
</blockquote>
<h1 id="使用自定义域名"><a href="#使用自定义域名" class="headerlink" title="使用自定义域名"></a>使用自定义域名</h1><blockquote>
<p>上面的url中”kasdad”是随机生成的域名，如果你需要自定义自己的域名，以“wahaha”为例，可以使用命令：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lt --subdomain wahaha --port 3000 </div><div class="line">或 </div><div class="line">lt <span class="_">-s</span> wahaha -p 3000 </div><div class="line">//subdomain的字符数限制在4到63个字符之间。</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><ul>
<li><a href="https://github.com/localtunnel/localtunnel" target="_blank" rel="external">localtunnel的github地址</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Localtunnel将你的localhost服务暴露向外网，方便测试和分享！不需要DNS解析和部署就可以让别人轻
    
    </summary>
    
      <category term="工具" scheme="http://blog.honghaibin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="node" scheme="http://blog.honghaibin.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>论一名前端工程师の自我修养</title>
    <link href="http://blog.honghaibin.com/2017/05/22/%E5%89%8D%E7%AB%AF%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.honghaibin.com/2017/05/22/前端规范/</id>
    <published>2017-05-22T13:42:00.000Z</published>
    <updated>2017-05-24T03:19:35.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-可维护性"><a href="#1-可维护性" class="headerlink" title="1. 可维护性"></a>1. 可维护性</h1><blockquote>
<p>很多时候，我们不是从零开始，开发新代码。而是去维护别人的代码，以他人的工作成果为基础。确保自己的代码可维护，是赠人玫瑰，
手留余香的好事。一方面让别人看的舒服，另一方面也防止自己长时间没看过自己的代码，自己都难以理解。</p>
</blockquote>
<h2 id="1-1-什么是可维护性代码"><a href="#1-1-什么是可维护性代码" class="headerlink" title="1.1 什么是可维护性代码"></a>1.1 什么是可维护性代码</h2><blockquote>
<p>可维护性代码的一些特征：</p>
<ul>
<li><strong>可理解</strong> ：易于理解代码的用途</li>
<li><strong>可适应</strong> ：数据的变化，不需要完全重写代码</li>
<li><strong>可扩展</strong> ：要考虑未来对核心功能的扩展</li>
<li><strong>可调试</strong> ：给出足够的信息，让调试的时候，确定问题所在</li>
<li><strong>不可分割</strong> ：函数的功能要单一，功能粒度不可分割，可复用性增强</li>
</ul>
</blockquote>
<h2 id="1-2-代码约定"><a href="#1-2-代码约定" class="headerlink" title="1.2 代码约定"></a>1.2 代码约定</h2><p><strong>1.2.1 可读性</strong></p>
<ul>
<li><strong>统一的缩进方式</strong> ： 一般使用4个空格，不用制表符是因为制表符在不同的编辑器里的效果不同。</li>
<li><strong>注释</strong> ： 函数和方法、大段代码、复杂的算法、hack</li>
<li><strong>空白行</strong> ： 方法之间、方法里的局部变量和第一个语句之间、单行或者多行注释之间、方法内依个逻辑单元之间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Good</div><div class="line">if (wl &amp;&amp; wl.length) &#123;</div><div class="line"></div><div class="line">    for (i = 0, l = wl.length; i &lt; l; ++i) &#123;</div><div class="line">        p = wl[i];</div><div class="line">        type = Y.Lang.type(r[p]);</div><div class="line"></div><div class="line">        if (s.hasOwnProperty(p)) &#123;</div><div class="line"></div><div class="line">            if (merge &amp;&amp; type == &apos;object&apos;) &#123;</div><div class="line">                Y.mix(r[p], s[p]);</div><div class="line">            &#125; else if (ov || !(p in r)) &#123;</div><div class="line">                r[p] = s[p];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>1.2.2 变量名和函数名</strong></p>
<ul>
<li><em>驼峰命名法</em></li>
<li><em>变量名以名词开头</em></li>
<li><em>方法名以动词开头</em></li>
<li><em>常量全部大写</em></li>
<li><em>构造函数以大写字母开头</em></li>
<li><em>jquery对象以“$”符号开头</em></li>
</ul>
<blockquote>
<p>变量命名不仅仅是一种科学，更是一种艺术。总之，要短小精悍，见名知意。有些名词可以反应出变量的类型。</p>
</blockquote>
<ul>
<li><p>变量名：</p>
<table>
  <thead>
      <tr>
          <th>名词</th>
          <th>数据类型含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>count,length,size</td>
          <td>数值</td>
      </tr>
      <tr>
          <td>name,title,message</td>
          <td>字符串</td>
      </tr>
      <tr>
          <td>i,j,k</td>
          <td>用来循环</td>
      </tr>
      <tr>
          <td>car,person,student,user</td>
          <td>对象</td>
      </tr>
      <tr>
          <td>success,fail</td>
          <td>布尔值</td>
      </tr>
      <tr>
          <td>payload</td>
          <td>post数据的请求体</td>
      </tr>
      <tr>
          <td>method</td>
          <td>请求方式</td>
      </tr>
  </tbody>
</table>
</li>
<li><p>函数名：</p>
<table>
  <thead>
      <tr>
          <th>动词</th>
          <th>用法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>resend</td>
          <td>重发</td>
      </tr>
      <tr>
          <td>validate</td>
          <td>验证</td>
      </tr>
      <tr>
          <td>query</td>
          <td>查询</td>
      </tr>
      <tr>
          <td>create</td>
          <td>创建</td>
      </tr>
      <tr>
          <td>add</td>
          <td>添加</td>
      </tr>
      <tr>
          <td>delete</td>
          <td>删除</td>
      </tr>
      <tr>
          <td>remove</td>
          <td>移除</td>
      </tr>
      <tr>
          <td>insert</td>
          <td>插入</td>
      </tr>
      <tr>
          <td>update</td>
          <td>更新</td>
      </tr>
      <tr>
          <td>copy</td>
          <td>复制</td>
      </tr>
      <tr>
          <td>render</td>
          <td>渲染</td>
      </tr>
      <tr>
          <td>close</td>
          <td>关闭</td>
      </tr>
      <tr>
          <td>open</td>
          <td>开启</td>
      </tr>
      <tr>
          <td>clear</td>
          <td>清除</td>
      </tr>
      <tr>
          <td>edit</td>
          <td>编辑</td>
      </tr>
      <tr>
          <td>on</td>
          <td>当事件发生</td>
      </tr>
      <tr>
          <td>list</td>
          <td>渲染一个列表，例如 <em>listUsersList()</em> 或 <em>listUsers()</em></td>
      </tr>
  </tbody>
</table>
</li>
<li><p>接口常用的动词：</p>
<table>
  <thead>
      <tr>
          <th>含义</th>
          <th>请求方法</th>
          <th>词语</th>
          <th>例子</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>增加</td>
          <td>post</td>
          <td>create</td>
          <td>createUser</td>
      </tr>
      <tr>
          <td>删除</td>
          <td>delete</td>
          <td>delete</td>
          <td>deleteUser</td>
      </tr>
      <tr>
          <td>修改</td>
          <td>update</td>
          <td>update</td>
          <td>updateUser</td>
      </tr>
      <tr>
          <td>查询</td>
          <td>get</td>
          <td>get,query</td>
          <td>getUser,queryUser(无条件查询用get，有条件的查询用query)</td>
      </tr>
  </tbody>
</table>
</li>
<li><p>学会使用单复数命名函数：</p>
<table>
  <thead>
      <tr>
          <th>函数名</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>getUser()</td>
          <td>获取一个用户，一般是通过唯一的id来获取</td>
      </tr>
      <tr>
          <td>getUsers()</td>
          <td>获取一类用户，一般是通过一些条件来获取</td>
      </tr>
      <tr>
          <td>createUser()</td>
          <td>创建一个用户</td>
      </tr>
      <tr>
          <td>createUsers()</td>
          <td>批量创建用户</td>
      </tr>
  </tbody>
</table>
</li>
<li><p>常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var MAX_COUNT= 10;</div><div class="line">var URL= &quot;http://material.io&quot;;</div></pre></td></tr></table></figure>
</li>
<li><p>构造函数：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Good</div><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">var me = new Person(&quot;wdd&quot;);</div></pre></td></tr></table></figure>
<ul>
<li>底层http请求接口函数：</li>
</ul>
<blockquote>
<p>建议使用“_”开头，例如App._getUsers();而对于接口函数的封装，例如App.getUsers()，内部逻辑调用App._getUsers();</p>
</blockquote>
<p><strong>1.2.3 文件名</strong></p>
<pre><code>* 全部使用小写字母
* 单词之间用“_”间隔
</code></pre><p>eg:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app-main.js</div><div class="line">app-event.js</div></pre></td></tr></table></figure></p>
<p><strong>1.2.4 文件归类</strong></p>
<blockquote>
<p>自己写的js最好和第三方插件放置在不同的文件夹下。</p>
</blockquote>
<p><strong>1.2.5 alert只用于调试</strong></p>
<blockquote>
<ul>
<li>如果你用alert来显示提醒消息，那么用户除了点击alert上的的确定按钮外，就只能点击上面的关闭，或者选择禁止再选择对话框，除此以外什么都不能操作。</li>
<li>有些浏览器如果禁止了alert的选项，那么你的alert是不会显示的</li>
<li>如果你在try catch语句里使用alert，那么console里将不会输出错误信息，你都没办法查看错误的详细原因，以及储出错的位置。</li>
</ul>
</blockquote>
<p>优雅的方式：</p>
<blockquote>
<ul>
<li>console.log() 普通提示消息
console.error() 错误提示消息
console.info() 信息提示消息
console.warn() 警告提示消息</li>
</ul>
</blockquote>
<h2 id="1-3-松散耦合"><a href="#1-3-松散耦合" class="headerlink" title="1.3 松散耦合"></a>1.3 松散耦合</h2><blockquote>
<ul>
<li>html文件最好避免写js语句</li>
<li>尽量避免在js更改某个css类的属性，而使用更改类的方法</li>
<li>解耦应用逻辑和事件处理程序</li>
</ul>
</blockquote>
<p><strong>1.3.1 将应用逻辑和事件处理程序解耦</strong></p>
<ul>
<li>错误的做法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//一般事件订阅的写法，以jQuery的写法为栗子</div><div class="line">$(document).on(&apos;click&apos;,&apos;#btn-get-users&apos;,function(event)&#123;</div><div class="line">    event.stopPropagation();</div><div class="line"></div><div class="line">    //下面的省略号表示执行获取所有用于并显示在页面上的逻辑</div><div class="line">    // Bad</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    //</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果增加了需求，当点击另外一个按钮的时候，也要执行获取所有用户并显示在页面上，那么上面省略的代码又要复制一份。如果接口有改动，那么需要在两个不同的地方都要修改。所以，应该这样。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(document).on(&apos;click&apos;,&apos;#btn-get-users&apos;,function(event)&#123;</div><div class="line">    event.stopPropagation();</div><div class="line"></div><div class="line">    //将应用逻辑分离在其他个函数中</div><div class="line">    // Good</div><div class="line">    App.getUsers();</div><div class="line">    App.renderUsers();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>1.3.2 松散解耦原则</strong></p>
<ul>
<li>不要将event对象传给其他方法，只传递来自event对象中的某些数据。</li>
<li>任何事件处理程序都应该只处理事件，然后将处理转交给应用逻辑。</li>
</ul>
<p><strong>1.3.3 将异步请求和数据处理解耦</strong></p>
<ul>
<li>错误做法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Bad</div><div class="line">ReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123;</div><div class="line">    if(!res.success)&#123;</div><div class="line">        console.error(res);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //对数据的处理</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码对数据的处理直接写死在异步请求里面，如果换了一个请求，但是数据处理方式是一样的，那么又要复制一遍数据处理的代码。最好的方式是将数据处理模块化成为一个函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Good</div><div class="line">ReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123;</div><div class="line">    if(!res.success)&#123;</div><div class="line">        console.error(res);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //对数据的处理</div><div class="line">    App.renderUsers(res.data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>ps:异步请求只处理请求，不处理数据。函数的功能要专一，功能粒度不可分割。</p>
<p><strong>1.3.4 不要将某个变量写死在函数中，尽量使用参数传递进去</strong></p>
<p>如果你需要一个函数去验证输入框是否是空，如下。这种方式就会绑定死了这个只能验证id为test的输入框，换成其他的就不行。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">function checkInputIsEmpty()&#123;</div><div class="line">    var value = $(&apos;#test&apos;).val();</div><div class="line">    if(value)&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function isEmptyInput(id)&#123;</div><div class="line">    var value = $(&apos;#&apos;+id).val();</div><div class="line">    if(value)&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-4-编程实践"><a href="#1-4-编程实践" class="headerlink" title="1.4 编程实践"></a>1.4 编程实践</h2><p><strong>1.4.1 尊重对象所有权</strong></p>
<p>javascript的动态性质决定了几乎属于它的任何东西在任何时间都能发生更改，这样就很可能会篡改一些默认的方法，从而导致一些灾难性的后果。<em>如果你不负责或者维护某一个对象，那么你就不能对它进行更改。</em></p>
<pre><code>* 不要为实例或原型添加属性和方法
* 不要重定义已存在的方法
</code></pre><p><strong>1.4.2 避免全局变量</strong></p>
<p><em>避免全局变量的深层原因在于避免作用域污染</em></p>
<p><em>作用域就像空气，你时时刻刻不在呼吸，但你往往感觉不到它的存在。一旦它本污染。你就会感到窒息</em>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Bad 两个全局变量</div><div class="line">var name = &quot;wdd&quot;;</div><div class="line">funtion getName()&#123;</div><div class="line">    console.log(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Good 一个全局变量</div><div class="line">var App = &#123;</div><div class="line">    name:&quot;wdd&quot;,</div><div class="line">    sayName:funtion()&#123;</div><div class="line">        console.log(this.name);//如果这个函数当做回调数使用，这个this可能指向window,</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>1.4.3 避免与null进行比较</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//Bad</div><div class="line">funtion sortArray(values)&#123;</div><div class="line">    // 避免</div><div class="line">    if(values != null)&#123;</div><div class="line">        values.sort(comparator);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//Good</div><div class="line">function sortArray(values)&#123;</div><div class="line">    // 推荐</div><div class="line">    if(values instanceof Array)&#123;</div><div class="line">        values.sort(compartor);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与null进行比较的代码，可以用以下技术进行替换
&gt;</p>
<ul>
<li>如果值是一个应用类型，使用instanceof操作符，检查其构造函数</li>
<li>如果值是基本类型，使用typeof检查其类型</li>
<li>如果是希望对象包含某个特定的方法名，则只用typeof操作符确保指定名字的方法存在于对象上。</li>
</ul>
<p><strong><em>代码中与null比较越少，就越容易确定代码的目的，消除不必要的错误。</em></strong></p>
<p><strong>1.4.4 从代码中分离配置文件</strong></p>
<p>配置数据是一些硬代码(hardcoded),看下面的例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function validate(value)&#123;</div><div class="line">    if(!value)&#123;</div><div class="line">        alert(&apos;Invalid value&apos;);</div><div class="line">        location.href = &apos;/errors/invalid.php&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码里有两个配置数据，一个是UI字符串(‘Invalid value’),另一个是一个Url(‘/error/invalid.php’)。如果你把他们写死在代码里，那么如果当你需要修改这些地方的时候，那么你必须一处一处的检查并修改，而且还可能会遗漏。</p>
<p>所以第一步是要区分，哪些代码应该写成配置文件的形式？</p>
<pre><code>* 显示在UI元素中的字符串
* URL
* 一些重复的唯一值（例如URL）
* 一些设置变量
* 任何可能改变的值
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Config = &#123;</div><div class="line">    &quot;MSG_INVALID_VALUE&quot;:&quot;Invalid value&quot;,</div><div class="line">    &quot;URL_INVALID&quot;:&quot;/errors/invalid.php&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>1.4.5 调试信息开关</strong></p>
<p>在开发过程中，可能随处留下几个console.log,或者alert语句，这些语句在开发过程中是很有价值的。但是项目一旦进入生产环境，过多的console.log可能影响到浏览器的运行效率，过多的alert会降低程序的用户体验。而我们最好不要在进入生产环境前，一处一处像扫雷一样删除或者注释掉这些调试语句。</p>
<blockquote>
<p>最好的方法就是设置一个开关</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//全局命令空间</div><div class="line">var App = &#123;</div><div class="line">    debug:true,</div><div class="line">    log:function(msg)&#123;</div><div class="line">        if(debug)&#123;</div><div class="line">            console.log(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    alert:function(msg)&#123;</div><div class="line">        if(debug)&#123;</div><div class="line">            alert(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//使用</div><div class="line">App.log(&apos;获取用户信息成功&apos;);</div><div class="line">App.alert(&apos;密码不匹配&apos;);</div><div class="line"></div><div class="line">//关闭日志输出与alert</div><div class="line">App.debug = false;</div></pre></td></tr></table></figure>
<p><strong>1.4.6 使用jQuery Promise</strong></p>
<p>没有使用promise之前的回调函数写法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// bad：没使用promise之前的回调函数写法</div><div class="line">function sendRequest(req,successCallback,errorCallback)&#123;</div><div class="line">    var inputData = req.data || &#123;&#125;;</div><div class="line">    inputData = JSON.stringify(inputData);</div><div class="line">    $.ajax(&#123;</div><div class="line">        url:req.base+req.destination,</div><div class="line">        type:req.type || &quot;get&quot;,</div><div class="line">        headers:&#123;</div><div class="line">            sessionId:session.id</div><div class="line">        &#125;,</div><div class="line">        data:inputData,</div><div class="line">        dataType:&quot;json&quot;,</div><div class="line">        contentType : &apos;application/json; charset=UTF-8&apos;,</div><div class="line">        success:function(data)&#123;</div><div class="line">            successCallback(data);</div><div class="line">        &#125;,</div><div class="line">        error:function(data)&#123;</div><div class="line">            console.error(data);</div><div class="line">            errorCallback(data);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用</div><div class="line">sendRequest(req,function(res)&#123;</div><div class="line">    ...</div><div class="line">&#125;,function(res)&#123;</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>使用promise之后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">function sendRequest(req)&#123;</div><div class="line">    var $dfd = $.Deferred();</div><div class="line">    var inputData = req.data || &#123;&#125;;</div><div class="line">    inputData = JSON.stringify(inputData);</div><div class="line">    $.ajax(&#123;</div><div class="line">        url:req.base+req.destination,</div><div class="line">        type:req.type || &quot;get&quot;,</div><div class="line">        headers:&#123;</div><div class="line">            sessionId:session.id</div><div class="line">        &#125;,</div><div class="line">        data:inputData,</div><div class="line">        dataType:&quot;json&quot;,</div><div class="line">        contentType : &apos;application/json; charset=UTF-8&apos;,</div><div class="line">        success:function(data)&#123;</div><div class="line">            $dfd.resolve(data);</div><div class="line">        &#125;,</div><div class="line">        error:function(data)&#123;</div><div class="line">            $dfd.reject(data);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return $dfd.promise();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用</div><div class="line">sendRequest(req)</div><div class="line">.done(function()&#123;</div><div class="line">    //请求成功</div><div class="line">    ...</div><div class="line">&#125;)</div><div class="line">.fail(function()&#123;</div><div class="line">    //请求失败</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>1.4.7 显示错误提醒，不要给后端接口背锅</strong></p>
<p>假如前端要去接口获取用户信息并显示出来，如果你的请求格式是正确的，但是接口返回400以上的错误，你必须通过提醒来告知测试，这个错误是接口的返回错误，而不是前端的逻辑错误。</p>
<p><strong>1.4.8 Restful接口请求</strong></p>
<blockquote>
<p>对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</p>
</blockquote>
<table>
    <thead>
        <tr>
            <th>请求类型</th>
            <th>接口前缀</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>GET</td>
            <td>.get</td>
        </tr>
        <tr>
            <td>POST</td>
            <td>.create</td>
        </tr>
        <tr>
            <td>PUT</td>
            <td>.update</td>
        </tr>
        <tr>
            <td>DELETE</td>
            <td>.delete</td>
        </tr>
    </tbody>
</table>

<p><em>有些接口获取某一些资源虽然是post请求，但是它的行为是get，所以建议使用.get</em></p>
<p>示例：</p>
<pre><code>// 与用户相关的接口
App.api.user = {};

// 获取一个用户: 一般来说是一个指定的Id，例如userId
App.api.user.getUser = function(){
    ...
};

// 获取一组用户: 一般来说是一些条件，获取条件下的用户，筛选符合条件的用户
App.api.user.getUsers = function(){
    ...
};

// 创建一个用户
App.api.user.createUser = function(){

};

// 创建一组用户
App.api.user.createUsers = function(){

};

// 更新一个用户
App.api.user.updateUser = function(){

};

// 更新一组用户
App.api.user.updateUsers = function(){

};

// 更新一个用户
App.api.user.updateUser = function(){

};

// 更新一组用户
App.api.user.updateUsers = function(){

};

// 删除一个用户
App.api.user.deleteUser = function(){

};

// 删除一组用户
App.api.user.deleteUsers = function(){

};
</code></pre><h1 id="2-性能"><a href="#2-性能" class="headerlink" title="2 性能"></a>2 性能</h1><h2 id="2-1-注意作用域"><a href="#2-1-注意作用域" class="headerlink" title="2.1 注意作用域"></a>2.1 注意作用域</h2><ul>
<li>避免全局查找</li>
<li>避免with语句,虽然方便，但是这个会进行全局搜索。
提示：with语句的用法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Lakers() &#123;  </div><div class="line">       this.name = &quot;kobe bryant&quot;;  </div><div class="line">       this.age = &quot;28&quot;;  </div><div class="line">       this.gender = &quot;boy&quot;;  </div><div class="line">&#125;  </div><div class="line">var people=new Lakers();  </div><div class="line">with(people)  </div><div class="line">&#123;  </div><div class="line">       var str = &quot;姓名: &quot; + name + &quot;&lt;br&gt;&quot;;  </div><div class="line">       str += &quot;年龄：&quot; + age + &quot;&lt;br&gt;&quot;;  </div><div class="line">       str += &quot;性别：&quot; + gender;  </div><div class="line">       document.write(str);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-2-选择正确的方法"><a href="#2-2-选择正确的方法" class="headerlink" title="2.2 选择正确的方法"></a>2.2 选择正确的方法</h2><ul>
<li><p>优化循环</p>
  <ul>
      <li><em>减值迭代：从最大值开始，在循环中不断减值的迭代器更加高效。</em></li>
      <li><em>简化终止条件：由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是避免其他属性查找。</em></li>
      <li><em>简化循环体：由于循环体是执行最多的，所以要确保其最大限度地优化。</em></li>
  </ul>
</li>
<li><p>展开循环</p>
</li>
<li><p>避免双重解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// **Bad** 某些代码求值</div><div class="line">eval(&quot;alert(&apos;hello&apos;)&quot;);</div><div class="line"></div><div class="line">// **Bad** 创建新函数</div><div class="line">var sayHi = new Function(&quot;alert(&apos;hello&apos;)&quot;);</div><div class="line"></div><div class="line">// **Bad** 设置超时</div><div class="line">setTimeout(&quot;alert(&apos;hello&apos;)&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>性能的其他注意事项</p>
  <ul>
      <li>原生方法较快</li>
      <li>switch语句较快：可以适当的替换ifelse语句case 的分支不要超过128条</li>
      <li>位运算符较快</li>
  </ul>

</li>
</ul>
<h2 id="2-3-最小化语句数"><a href="#2-3-最小化语句数" class="headerlink" title="2.3 最小化语句数"></a>2.3 最小化语句数</h2><p>多个变量声明：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 方式1：Bad</div><div class="line">var count = 5;</div><div class="line">var name = &apos;wdd&apos;;</div><div class="line">var sex = &apos;male&apos;;</div><div class="line">var age = 10;</div><div class="line"></div><div class="line">// 方式2：Good</div><div class="line">var count = 5,</div><div class="line">    name = &apos;wdd&apos;,</div><div class="line">    sex = &apos;male&apos;,</div><div class="line">    age = 10;</div><div class="line">_如果你觉得可读性变差了，可以不使用，个人很是喜欢这么写_</div></pre></td></tr></table></figure></p>
<p>插入迭代值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Good</div><div class="line">var name = values[i++];</div></pre></td></tr></table></figure></p>
<p>使用数组和对象字面量
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Good</div><div class="line">var values = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line"></div><div class="line">var person = &#123;</div><div class="line">    name:&apos;wdd&apos;,</div><div class="line">    age:10</div><div class="line">&#125;;</div><div class="line"></div><div class="line">提示：只要有可能，尽量使用数组和对象字面量的表达式来消除不必要的语句</div></pre></td></tr></table></figure></p>
<h2 id="2-4-优化DOM交互"><a href="#2-4-优化DOM交互" class="headerlink" title="2.4 优化DOM交互"></a>2.4 优化DOM交互</h2><blockquote>
<p>在JavaScript各个方面中，DOM无疑是最慢的一部分。DOM操作与交互要消耗大量的时间。因为他们往往需要重新渲染整个页面或者某一部分。进一步说，看似细微的操作也可能花很久来执行。因为DOM要处理非常多的信息。理解如何优化与DOM的交互可以极大的提高脚本完成的速度。</p>
</blockquote>
<ul>
<li>使用dom缓存技术</li>
<li>最小化现场更新</li>
<li>使用innerHTML插入大段的html</li>
<li>使用事件代理</li>
</ul>
<p><strong>2.4.1 Dom缓存技术</strong></p>
<p>调用频率非常高的dom查找，可以将Dom缓存于一个变量中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 最简单的dom缓存</div><div class="line"></div><div class="line">var domCache = &#123;&#125;;</div><div class="line">//如果之前查过一次，就用缓存中的</div><div class="line">function myGetElement(tag)&#123;</div><div class="line">    return domCache[tag] = domCache[tag] || $(tag);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-5-避免过长的属性查找，设置一个快捷方式"><a href="#2-5-避免过长的属性查找，设置一个快捷方式" class="headerlink" title="2.5 避免过长的属性查找，设置一个快捷方式"></a>2.5 避免过长的属性查找，设置一个快捷方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 先看下面的极端情况</div><div class="line">app.user.mother.parent.home.name = &apos;haha&apos;</div><div class="line">app.user.mother.parent.home.adderess = &apos;上海&apos;</div><div class="line">app.user.mother.parent.home.weather = &apos;晴天&apos;</div><div class="line"></div><div class="line">// 更优雅的方式</div><div class="line">var home = app.user.mother.parent.home;</div><div class="line">home.name = &apos;haha&apos;;</div><div class="line">home.address = &apos;上海&apos;,</div><div class="line">home.weather = &apos;晴天&apos;</div></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p>使用上面的方式是有前提的，必须保证app.user.mather.parent.home是一个对象，因为对象是传递的引用。如果他的类型是一个基本类型，例如：number,string,boolean，那么复制操作仅仅是值传递，新定义的home的改变，并不会影响到app.user.mather.parent.home的改变。</p>
</blockquote>
<h1 id="3-快捷方式"><a href="#3-快捷方式" class="headerlink" title="3 快捷方式"></a>3 快捷方式</h1><h2 id="3-1-字符串转数字"><a href="#3-1-字符串转数字" class="headerlink" title="3.1 字符串转数字"></a>3.1 字符串转数字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+&apos;4.1&apos; === 4.1  //true</div></pre></td></tr></table></figure>
<h2 id="3-2-数字转字符"><a href="#3-2-数字转字符" class="headerlink" title="3.2 数字转字符"></a>3.2 数字转字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.1+&quot;&quot;===&quot;4.1&quot;  //true</div></pre></td></tr></table></figure>
<h2 id="3-3-字符串取整"><a href="#3-3-字符串取整" class="headerlink" title="3.3 字符串取整"></a>3.3 字符串取整</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;4.99&apos; | 0===4  //true</div></pre></td></tr></table></figure>
<h1 id="4-推荐阅读"><a href="#4-推荐阅读" class="headerlink" title="4 推荐阅读"></a>4 推荐阅读</h1><ul>
<li><a href="https://book.douban.com/subject/10797189/" target="_blank">《编写可读代码的艺术》</a></li>
<li><a href="https://book.douban.com/subject/21792530/" target="_blank">《编写可维护的javascript》</a></li>
<li><a href="https://book.douban.com/subject/26638316/" target="_blank">《JavaScript忍者秘籍》</a></li>
</ul>
<p>写在最后的话：</p>
<ul>
<li>这篇文章原文出自我同事：
<a href="https://segmentfault.com/a/1190000007101196" target="_blank">前端干货之JS最佳实践</a></li>
</ul>
<p>我们毕业于一所大学，一起进公司实习，通过试用，最后转正。转眼间已经一年半了。
刚到公司那会儿，在没有前端前辈带我们的情况下，我们走了很多弯路，如今再看看我们以前敲的那些代码简直是不忍回去再看。也多亏了我这位同事善于钻研，带着我学习了很多新东西。他以后肯定会成为一个前端大牛的，恩~我也会努力成为一名前端大牛的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-可维护性&quot;&gt;&lt;a href=&quot;#1-可维护性&quot; class=&quot;headerlink&quot; title=&quot;1. 可维护性&quot;&gt;&lt;/a&gt;1. 可维护性&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;很多时候，我们不是从零开始，开发新代码。而是去维护别人的代码，以他人的工作成果
    
    </summary>
    
      <category term="规范" scheme="http://blog.honghaibin.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="前端" scheme="http://blog.honghaibin.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零开始--基于hexo搭建个人博客</title>
    <link href="http://blog.honghaibin.com/2017/04/19/hexo+github/"/>
    <id>http://blog.honghaibin.com/2017/04/19/hexo+github/</id>
    <published>2017-04-19T06:14:43.000Z</published>
    <updated>2017-05-24T01:21:00.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很早以前就想搭建一个个人技术博客了！我想用<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>搭建博客原因有三：第一，它是纯一个静态博客，很适合前端用来搭建；第二，它基于node（你们都懂，前端和node不分家）；第三，好看，相对于csdn那些博客，hexo搭建的博客简单朴实很多。
hexo的开发者是一个大学生啊（笑哭~~），我觉得我可能读了个假大学！
好了，感慨的话就不多说了，第一篇文章就献给hexo，感谢hexo！</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h3 id="拥有Github账号"><a href="#拥有Github账号" class="headerlink" title="拥有Github账号"></a>拥有Github账号</h3><p>这个就不多说了！（前端程序猿的基本素养）</p>
<h3 id="创建一个仓库-repository"><a href="#创建一个仓库-repository" class="headerlink" title="创建一个仓库(repository)"></a>创建一个仓库(repository)</h3><p>在github上创建一个仓库名称为  [yourname].github.io   ([yourname]是你的github昵称！)</p>
<h3 id="添加秘钥"><a href="#添加秘钥" class="headerlink" title="添加秘钥"></a>添加秘钥</h3><p>打开git bash命令行生成秘钥，命令如下：（友情提示:git官网下载很慢，记得先翻墙.）
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"Github的注册邮箱地址"</span></div></pre></td></tr></table></figure></p>
<p>一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入<a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a></p>
<h3 id="验证ssh"><a href="#验证ssh" class="headerlink" title="验证ssh"></a>验证ssh</h3><p>在github上添加完ssh之后并不会立刻生效，你需要在git bash命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>tip：如果你提交github不上的时候就要想到去验证一下ssh是否失效了。</p>
<p>在coding上添加完ssh之后也并不会立刻生效，你需要在git bash命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure>
<p>成功提示：
Hi xxxxxx! You’ve successfully authenticated, but GitCafe does not provide shell access.
然后刷新github的ssh设置页面，看到那一把钥匙变成绿色之后就说明你的环境已经部署好了。</p>
<h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><p>配置git：昵称和邮箱（我用的是github和hexo来搭建的，那就是我的github昵称和邮箱）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"yourname"</span></div><div class="line">git config --global user.email <span class="string">"youremail"</span></div></pre></td></tr></table></figure>
<h1 id="hexo安装配置："><a href="#hexo安装配置：" class="headerlink" title="hexo安装配置："></a>hexo安装配置：</h1><h3 id="下载安装、初始化"><a href="#下载安装、初始化" class="headerlink" title="下载安装、初始化"></a>下载安装、初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>安装好之后输入 hexo 可以查看hexo各项命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字</div><div class="line"> hexo init &lt;folder&gt;</div><div class="line">// 进入博客文件夹，&lt;folder&gt;为文件夹的名称</div><div class="line"> <span class="built_in">cd</span> &lt;folder&gt;</div><div class="line">// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包</div><div class="line"> cnpm install</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开_config.yml文件，这里进行简单的配置(详情可以查看<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">官方文档</a>):
1.修改网站相关信息：
  title: inerdstack
  subtitle: the stack of it nerds
  description: start from zero
  author: inerdstack
  language: zh-CN
  timezone: Asia/Shanghai
  language和timezone都是有输入规范的，详细可参考语言规范和时区规范。</p>
<p>2.配置统一资源定位符（个人域名）
  url:  <a href="http://balabala.com" target="_blank" rel="external">http://balabala.com</a> (这个url不能不写，不写会报错)</p>
<p>3.配置部署(repo是你创建的github仓库的pull地址，默认分支master) 
  deploy:
    type: git
    repo: <a href="https://github.com/yourname/yourname.github.io.git" target="_blank" rel="external">https://github.com/yourname/yourname.github.io.git</a>
    branch: master</p>
<p>  2017/05/20更新：由于在国内访问github加载速度不尽人意，所以我把项目同时部署到了github上和coding上，配置部署变化如下：
  deploy:
    type: git
    repo:
      github: ssh://git@github.com/yourname/yourname.github.io.git,master
      coding: ssh://git@git.coding.net/yourname/yourname.git,master</p>
<p>  tip:详细配置操作可以查看参考资料</p>
<h1 id="开始写文章"><a href="#开始写文章" class="headerlink" title="开始写文章"></a>开始写文章</h1><h3 id="创建一个文章"><a href="#创建一个文章" class="headerlink" title="创建一个文章"></a>创建一个文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>更多详情:：<a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">writing</a></p>
<h3 id="开启本地服务"><a href="#开启本地服务" class="headerlink" title="开启本地服务"></a>开启本地服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure>
<p>更多详情：<a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo generate</div></pre></td></tr></table></figure>
<p>更多详情: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<p>更多详情：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>写在最后的话：
    创建好博客之后你就可以通过地址 <a href="https://honghaibin.github.io/" target="_blank" rel="external">https://honghaibin.github.io/</a> 进行访问你的博客了，如果不想在地址中显示“github”的字样，你可以去 <a href="https://wanwang.aliyun.com/?spm=5176.8142029.388261.27.5tCELs" target="_blank" rel="external">万网</a> 租一个域名,然后将你申请的这个域名通过dns解析指向github这个服务就ok了，是不是很酷炫。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/icurious/article/details/53142450" target="_blank" rel="external">域名+解析+Github关联参考链接</a>
<a href="http://shomy.top/2016/03/03/hexo-in-coding-github/" target="_blank" rel="external">关于同时配置coding和github的参考链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很早以前就想搭建一个个人技术博客了！我想用&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;e
    
    </summary>
    
      <category term="教程" scheme="http://blog.honghaibin.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://blog.honghaibin.com/tags/Hexo/"/>
    
      <category term="git" scheme="http://blog.honghaibin.com/tags/git/"/>
    
      <category term="博客" scheme="http://blog.honghaibin.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
